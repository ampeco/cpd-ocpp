{"version":3,"sources":["../src/chargePoint.js"],"names":["debug","ChargePoint","options","connectors","centralSystemUrl","reconnectTimer","reconnectInterval","self","resolve","reject","ws","perMessageDeflate","protocolVersion","on","res","headers","Error","connection","nextReconnectAttempt","removeAllListeners","onRequest","command","clearInterval","setTimeout","connect","send","promises","getConnectors","map","connector","status","timestamp","Date","toISOString","statusCommand","StatusNotification","all"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;AAEA;;;;AAKA,IAAMA,QAAQ,8CAAd;;IAEqBC,W;AACnB;;;;;;;;AAQA,uBAAaC,OAAb,EAAsB;AAAA;;AACpBA,YAAQC,UAAR,GAAqBD,QAAQC,UAAR,IAAsB,EAA3C;;AAEA,SAAKD,OAAL,GAAeA,OAAf;AACD;;;;8BAEU;AAAA;;AACTF,gCAAwB,KAAKE,OAAL,CAAaE,gBAArC;;AAEA,UAAIC,uBAAJ;AACA,UAAMC,oBAAoB,KAAKJ,OAAL,CAAaI,iBAAb,IAAkC,IAAI,EAAJ,GAAS,IAArE,CAJS,CAIkE;AAC3E,UAAMC,OAAO,IAAb;;AAEA,aAAO,sBAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,YAAMC,KAAK,iBAAc,MAAKR,OAAL,CAAaE,gBAA3B,EAA6C,8BAA7C,EAAkE;AAC3EO,6BAAmB,KADwD;AAE3EC,2BAAiB;AAF0D,SAAlE,CAAX;;AAKAF,WAAGG,EAAH,CAAM,SAAN,EAAiB,UAACC,GAAD,EAAS;AACxB,cAAI,CAACA,IAAIC,OAAJ,CAAY,wBAAZ,CAAL,EAA4C;AAC1C,mBAAON,OAAO,IAAIO,KAAJ,oEAAP,CAAP;AACD;AACF,SAJD;;AAMAN,WAAGG,EAAH,CAAM,OAAN,EAAe,YAAM;AACnBb;AACA,gBAAKiB,UAAL,GAAkB,IAAlB;AACAC;AACD,SAJD;AAKAR,WAAGG,EAAH,CAAM,MAAN,EAAc,YAAM;AAClBH,aAAGS,kBAAH,CAAsB,OAAtB;;AAEA,gBAAKF,UAAL,GAAkB,2BAAeP,EAAf,CAAlB;AACA,gBAAKO,UAAL,CAAgBG,SAAhB,GAA4B,UAACC,OAAD;AAAA,mBAAa,MAAKD,SAAL,CAAeC,OAAf,CAAb;AAAA,WAA5B;;AAEAb,kBAAQ,MAAKS,UAAb;AACD,SAPD;;AASAP,WAAGG,EAAH,CAAM,OAAN,EAAeJ,MAAf;AACD,OA3BM,CAAP;;AA6BA,eAASS,oBAAT,GAAiC;AAAA;;AAC/B,YAAIb,cAAJ,EAAoB;AAClBiB,wBAAcjB,cAAd;AACAA,2BAAiB,IAAjB;AACD;;AAEDA,yBAAiBkB,oFAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBAElBhB,KAAKiB,OAAL,EAFkB;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAX,IAKdlB,iBALc,CAAjB;AAMD;AACF;;;yBAEKe,O,EAAS;AACb,UAAI,CAAC,KAAKJ,UAAV,EAAsB;AACpB,eAAO,KAAP;AACD;AACD,aAAO,KAAKA,UAAL,CAAgBQ,IAAhB,CAAqBJ,OAArB,CAAP;AACD;;;8BAEUA,O,EAAS,CACnB;;;oCAEgB;AACf,aAAO,KAAKnB,OAAL,CAAaC,UAApB;AACD;;;;;;;;;;;;AAGOuB,wB,GAAW,KAAKC,aAAL,GAAqBC,GAArB;AAAA,uGAAyB,kBAAOC,SAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAClCC,kCADkC;AAEtCC,yCAAW,IAAIC,IAAJ,GAAWC,WAAX;AAF2B,+BAGnCJ,SAHmC;AAKlCK,yCALkC,GAKlB,IAAI,mBAASC,kBAAb,CAAgCL,MAAhC,CALkB;AAAA;AAAA,mCAOlC,OAAKL,IAAL,CAAUS,aAAV,CAPkC;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAzB;;AAAA;AAAA;AAAA;AAAA,oB;;uBAUJ,kBAAQE,GAAR,CAAYV,QAAZ,C;;;;;;;;;;;;;;;;;;;;;;;kBA3FIzB,W","file":"chargePoint.js","sourcesContent":["import WebSocket from 'ws';\nimport debugFn from 'debug';\nimport Commands from './commands';\nimport { Connection } from './connection';\n\nimport {\n  OCPP_PROTOCOL_1_6,\n  DEBUG_LIBNAME\n} from './constants';\n\nconst debug = debugFn(DEBUG_LIBNAME);\n\nexport default class ChargePoint {\n  /**\n   * Create OCPP client\n   *\n   * @param {Object} options Configuration options\n   * @param {String} options.centralSystemUrl The url where to connect\n   * @param {String} options.reconnectInterval The number of milliseconds to delay before attempting to reconnect (default: 5 minutes)\n   * @param {String} options.connectors Array of virtual connectors\n   */\n  constructor (options) {\n    options.connectors = options.connectors || [];\n\n    this.options = options;\n  }\n\n  connect () {\n    debug(`Try connect to ${this.options.centralSystemUrl}`);\n\n    let reconnectTimer;\n    const reconnectInterval = this.options.reconnectInterval || 5 * 60 * 1000; // 5 minutes\n    const self = this;\n\n    return new Promise((resolve, reject) => {\n      const ws = new WebSocket(this.options.centralSystemUrl, [OCPP_PROTOCOL_1_6], {\n        perMessageDeflate: false,\n        protocolVersion: 13\n      });\n\n      ws.on('upgrade', (res) => {\n        if (!res.headers['sec-websocket-protocol']) {\n          return reject(new Error(`Server doesn't support protocol ${OCPP_PROTOCOL_1_6}`));\n        }\n      });\n\n      ws.on('close', () => {\n        debug(`Connection is closed`);\n        this.connection = null;\n        nextReconnectAttempt();\n      });\n      ws.on('open', () => {\n        ws.removeAllListeners('error');\n\n        this.connection = new Connection(ws);\n        this.connection.onRequest = (command) => this.onRequest(command);\n\n        resolve(this.connection);\n      });\n\n      ws.on('error', reject);\n    });\n\n    function nextReconnectAttempt () {\n      if (reconnectTimer) {\n        clearInterval(reconnectTimer);\n        reconnectTimer = null;\n      }\n\n      reconnectTimer = setTimeout(async () => {\n        try {\n          await self.connect();\n        } catch (err) {\n        }\n      }, reconnectInterval);\n    }\n  }\n\n  send (command) {\n    if (!this.connection) {\n      return false;\n    }\n    return this.connection.send(command);\n  }\n\n  onRequest (command) {\n  }\n\n  getConnectors () {\n    return this.options.connectors;\n  }\n\n  async sendCurrentStatus() {\n    const promises = this.getConnectors().map(async (connector) => {\n      const status = {\n        timestamp: new Date().toISOString(),\n        ...connector\n      };\n      const statusCommand = new Commands.StatusNotification(status);\n\n      await this.send(statusCommand)\n    });\n\n    return await Promise.all(promises);\n  }\n}\n"]}